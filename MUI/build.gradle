/* ###
* IP: GHIDRA
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

plugins {
    id "de.undercouch.download" version "5.1.0"
    id "com.diffplug.spotless" version "6.1.0"
    id "com.google.protobuf" version "0.8.18"
    id "java"
}

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
    ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
    ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
    apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
    throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------


def ghidraDir = file(ghidraInstallDir + "/Ghidra").getCanonicalFile().getAbsolutePath()
def ghidraProps = new Properties()
def ghidraVersion
def ghidraUserDirectory
def ghidraReleaseName


file(ghidraDir + "/application.properties").withReader { reader ->
    ghidraProps.load(reader)
        ghidraReleaseName = ghidraProps.getProperty('application.release.name')
    ghidraVersion = ghidraProps.getProperty('application.version')
    ghidraUserDirectory = "${project.gradle.gradleUserHomeDir.parent}/.ghidra/.ghidra_${ghidra_version}_${ghidraReleaseName}"
}

def userDir = new File(ghidraUserDirectory)
if(!userDir.exists()){
    userDir.mkdirs()
}


repositories {
    maven { url "https://maven-central.storage-download.googleapis.com/maven2/" }
    mavenCentral()
}


def grpcVersion = '1.44.1'
def protobufVersion = '3.19.2'
def protocVersion = protobufVersion


dependencies {
    implementation "io.grpc:grpc-protobuf:${grpcVersion}"
    implementation "io.grpc:grpc-stub:${grpcVersion}"
    compileOnly "org.apache.tomcat:annotations-api:6.0.53"

    // examples/advanced need this for JsonFormat
    implementation "com.google.protobuf:protobuf-java-util:${protobufVersion}"

    runtimeOnly "io.grpc:grpc-netty-shaded:${grpcVersion}"

    testImplementation "io.grpc:grpc-testing:${grpcVersion}"
}

task downloadProtobufSpec(type: Download) {
    src 'https://raw.githubusercontent.com/trailofbits/ManticoreUI-Ghidra/f560453e7f3b70bafc356daccaef15d1f1f08f00/MUICore/muicore/MUICore.proto'
    dest 'src/main/proto/MUICore.proto'
    onlyIfModified true
}

task downloadServerBinary(type: Download) {
    src 'https://github.com/trailofbits/ManticoreUI-Ghidra/raw/a1e1dcfa9bdf2f05ff9e857f5afa8bf4c3496c8e/MUI/os/linux_x86_64/muicore_server'
    dest 'os/linux_x86_64/muicore_server'
    onlyIfModified true
}

task downloadSolcBinary(type: Download) {
    src 'https://github.com/ethereum/solc-bin/raw/gh-pages/linux-amd64/solc-linux-amd64-v0.8.9%2Bcommit.e5eed63a'
    dest 'os/linux_x86_64/solc'
    onlyIfModified true
}

protobuf {
    generatedFilesBaseDir = "$projectDir/src"
    protoc {
        artifact = "com.google.protobuf:protoc:${protocVersion}"
    }
    plugins {
        grpc {
            artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}"
        }
    }
    generateProtoTasks {
        all()*.plugins {
              grpc {}
        }
    }
}

tasks.whenTaskAdded { task ->
    if (task.name == 'extractIncludeProto'){
        task.getDependsOn().add(copyDependencies)
    } else if (task.name == 'generateProto'){
        if (!project.hasProperty('KEEP_PROTOBUF_SPEC')) {
            task.dependsOn downloadProtobufSpec
        }
        zipSource.dependsOn task
        processResources.dependsOn task
        spotlessJava.dependsOn task
    }
}

// The following installation helpers were copied from
// https://github.com/cmu-sei/kaiju/blob/c00a351aa4332e8b6e2be94f6fe52418f8946b11/build.gradle
task uninstallPreviousMUI {
    description = "Removes a previous MUI installation, or notifies user of previous installation"
    doFirst {
        // check if a previous MUI installation exists
        if (new File(ghidraUserDirectory + '/Extensions/MUI').exists()) {
            // automatically remove past install if user specifies
            if (project.hasProperty('MUI_AUTO_REMOVE')) {
                def muiDir = new File(ghidraUserDirectory + '/Extensions/MUI/')
                muiDir.deleteDir()
                logger.quiet("SUCCESS! Previous standalone MUI installation was removed automatically by gradle.")
            } else {
                throw new GradleException("FATAL ERROR! A previous installation of MUI was detected. It is recommended that you either manually remove this installation before re-installing MUI, or re-run this gradle installation script with the -PMUI_AUTO_REMOVE option.")
            }
        }
    }
    outputs.upToDateWhen { false } // ensures never cached, always runs if user enables
}

build.dependsOn uninstallPreviousMUI


task installZip(type: Exec) {
    if (!project.hasProperty('KEEP_SERVER_BINARY')) {
        buildExtension.dependsOn downloadServerBinary
        buildExtension.dependsOn downloadSolcBinary
    }
    dependsOn buildExtension
    group = "Installation"
    description = "Installs the zip package in installed Ghidra's default extension directory"
    def zipPath = buildExtension.destinationDirectory.get().getAsFile().toString() + "/" + buildExtension.archiveBaseName.get() + "." + buildExtension.archiveExtension.get()
    commandLine 'unzip', '-o', zipPath, '-d', ghidraUserDirectory+'/Extensions/'
}

task install() {
    dependsOn installZip
    group = "Installation"
    description = "Alternate name for installZip task"
    //title = "Install zip"
    doLast {
        // Empty action list
        logger.quiet("Installed Trail of Bits MUI from zip!")
    }
}
// End copy

// Code style formatting
spotless {
    // optional: limit format enforcement to just the files changed by this feature branch
    // ratchetFrom 'origin/main'

    format 'misc', {
        // define the files to apply `misc` to
        target '*.gradle', '*.md', '.gitignore'

        // define the steps to apply to those files
        trimTrailingWhitespace()
        indentWithSpaces(4)
        endWithNewline()
    }
    java {
        target 'src/*/java/mui/**/*.java', 'ghidra_scripts/*.java'
        targetExclude('src/main/java/muicore/**/*.java')
        targetExclude('src/main/grpc/**/*.java')
        // The Ghidra formatting file was taken from Ghidra 10.1.1 located in
        // eclipse/GhidraEclipseFormatter.xml Ghidra repo
        eclipse().configFile('GhidraEclipseFormatter.xml')
    }
}
